<!DOCTYPE html>
<html lang="ar" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Database Management Systems Exam</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #4f46e5;
        --secondary-color: #818cf8;
        --bg-color: #f3f4f6;
        --card-bg: #ffffff;
        --text-color: #1f2937;
        --text-light: #6b7280;
        --border-color: #e5e7eb;
        --hover-color: #eef2ff;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Poppins", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        line-height: 1.6;
        padding: 40px 20px;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
      }

      header {
        text-align: center;
        margin-bottom: 40px;
      }

      header h1 {
        font-size: 2.5rem;
        color: var(--primary-color);
        margin-bottom: 10px;
      }

      header p {
        color: var(--text-light);
        font-size: 1.1rem;
      }

      .print-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 25px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 20px auto;
      }

      .print-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
      }

      .print-button:active {
        transform: translateY(0);
      }

      @media print {
        .print-button {
          display: none;
        }

        .check-button {
          display: none;
        }

        .result-section {
          display: none;
        }

        body {
          padding: 20px;
        }

        .question-card {
          page-break-inside: avoid;
          box-shadow: none;
          border: 1px solid #e5e7eb;
        }

        .erd-section {
          page-break-inside: avoid;
        }
      }

      .check-button {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        border-radius: 25px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 30px auto;
      }

      .check-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
      }

      .result-section {
        background: white;
        border-radius: 12px;
        padding: 25px;
        margin: 30px 0;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: none;
      }

      .result-section.show {
        display: block;
      }

      .score-display {
        text-align: center;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      .score-display h2 {
        font-size: 2rem;
        margin-bottom: 10px;
      }

      .explanation-box {
        background: #f0f9ff;
        border-left: 4px solid #3b82f6;
        padding: 15px;
        margin-top: 10px;
        border-radius: 5px;
        display: none;
      }

      .explanation-box.show {
        display: block;
      }

      .explanation-box.correct {
        background: #f0fdf4;
        border-left-color: #10b981;
      }

      .explanation-box.wrong {
        background: #fef2f2;
        border-left-color: #ef4444;
      }

      .explanation-title {
        font-weight: 600;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .correct-answer {
        color: #059669;
        font-weight: 600;
      }

      .wrong-answer {
        color: #dc2626;
        font-weight: 600;
      }

      .option-label.correct {
        border-color: #10b981;
        background-color: #f0fdf4;
      }

      .option-label.wrong {
        border-color: #ef4444;
        background-color: #fef2f2;
      }

      .context-box {
        background: #fffbeb;
        border-left: 5px solid #f59e0b;
        padding: 20px;
        margin: 30px 0;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
      }

      .context-box h3 {
        color: #b45309;
        margin-bottom: 10px;
        font-size: 1.2rem;
      }

      .question-card {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
          0 2px 4px -1px rgba(0, 0, 0, 0.06);
        transition: transform 0.2s ease;
      }

      .question-card:hover {
        transform: translateY(-2px);
      }

      .q-header {
        display: flex;
        align-items: flex-start;
        margin-bottom: 15px;
      }

      .q-number {
        background: var(--primary-color);
        color: white;
        width: 35px;
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        font-weight: 600;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .q-text {
        font-size: 1.1rem;
        font-weight: 500;
      }

      .options-list {
        list-style: none;
        padding-left: 50px;
      }

      .option-item {
        margin-bottom: 10px;
      }

      .option-label {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .option-label:hover {
        background-color: var(--hover-color);
        border-color: var(--secondary-color);
      }

      input[type="radio"] {
        display: none;
      }

      .radio-custom {
        width: 20px;
        height: 20px;
        border: 2px solid var(--text-light);
        border-radius: 50%;
        margin-right: 15px;
        position: relative;
      }

      input[type="radio"]:checked + .radio-custom {
        border-color: var(--primary-color);
        background-color: var(--primary-color);
      }

      input[type="radio"]:checked + .radio-custom::after {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 8px;
        height: 8px;
        background: white;
        border-radius: 50%;
      }

      input[type="radio"]:checked ~ .option-text {
        color: var(--primary-color);
        font-weight: 600;
      }

      /* ERD Image Section Styling */
      .erd-section {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 16px;
        padding: 30px;
        margin: 40px 0;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      }

      .erd-header {
        text-align: center;
        color: white;
        margin-bottom: 25px;
      }

      .erd-header h3 {
        font-size: 1.5rem;
        margin-bottom: 10px;
      }

      .erd-header p {
        font-size: 1rem;
        opacity: 0.95;
      }

      .erd-image-container {
        background: white;
        border-radius: 12px;
        padding: 20px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      .erd-upload-zone {
        border: 3px dashed #818cf8;
        border-radius: 10px;
        padding: 40px 20px;
        background: #f9fafb;
        transition: all 0.3s ease;
        cursor: pointer;
      }

      .erd-upload-zone:hover {
        background: #eef2ff;
        border-color: #4f46e5;
      }

      .erd-upload-zone.has-image {
        border-style: solid;
        padding: 0;
        background: transparent;
      }

      .upload-icon {
        font-size: 3rem;
        color: #4f46e5;
        margin-bottom: 15px;
      }

      .upload-text {
        color: #6b7280;
        font-size: 1rem;
        margin-bottom: 10px;
      }

      .upload-instruction {
        color: #9ca3af;
        font-size: 0.875rem;
      }

      #erdImage {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        display: none;
      }

      #erdImage.show {
        display: block;
      }

      .image-caption {
        margin-top: 15px;
        color: #6b7280;
        font-size: 0.9rem;
        font-style: italic;
        text-align: center;
      }

      .upload-button {
        background: #4f46e5;
        color: white;
        border: none;
        padding: 10px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        transition: background 0.3s ease;
        margin-top: 10px;
      }

      .upload-button:hover {
        background: #4338ca;
      }

      #fileInput {
        display: none;
      }

      @media (max-width: 600px) {
        .options-list {
          padding-left: 0;
        }
        .q-header {
          flex-direction: column;
        }
        .q-number {
          margin-bottom: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>DBMS Final Exam</h1>
        <p>
          Comprehensive Assessment on Database Concepts, Normalization, SQL, and
          ERD Mapping.
        </p>
        <button class="print-button" onclick="window.print()">
          <span>üñ®Ô∏è</span>
          <span>Print Exam</span>
        </button>
      </header>

      <div id="quiz-content"></div>

      <button class="check-button" onclick="checkAnswers()">
        <span>‚úÖ</span>
        <span>Check Answers</span>
      </button>

      <div class="result-section" id="resultSection">
        <div class="score-display" id="scoreDisplay"></div>
      </div>
    </div>

    <script>
      const quizData = [
        {
          q: "... a collection of concepts that describe the structure of a database.",
          options: ["Data model", "Domain", "Data control"],
          id: 1,
          correct: "A",
          explanation:
            "Data model is a collection of concepts that describe the structure of a database, including data types, relationships, and constraints.",
        },
        {
          q: "... is a structure that makes the search for particular database records efficient.",
          options: ["Access path", "Index", "DDL"],
          id: 2,
          correct: "B",
          explanation:
            "An Index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space.",
        },
        {
          q: "Atomicity property of transaction means:",
          options: [
            "Cannot be NULL",
            "All operations in a transaction are executed or none are",
            "Write operations in a transaction are executed or none are",
          ],
          id: 3,
          correct: "B",
          explanation:
            "Atomicity ensures that all operations within a transaction are completed successfully; if not, the transaction is aborted and all changes are rolled back.",
        },
        {
          q: "... describes the database structure in a way that will be implemented in DBMS.",
          options: ["Logical data", "Record-based", "DDL"],
          id: 4,
          correct: "A",
          explanation:
            "Logical data model describes the database structure at a conceptual level that can be implemented in a DBMS, independent of physical storage details.",
        },
        {
          q: "... means that non key attribute is dependent on non key attribute.",
          options: [
            "Function dependency",
            "Transitive dependency",
            "Data control",
          ],
          id: 5,
          correct: "B",
          explanation:
            "Transitive dependency occurs when a non-key attribute depends on another non-key attribute, which in turn depends on the primary key (A‚ÜíB and B‚ÜíC, therefore A‚ÜíC).",
        },
        {
          q: "The logical representation of an organization's data is called.",
          options: ["Internal", "DBMS", "Conceptual data model"],
          id: 6,
          correct: "C",
          explanation:
            "Conceptual data model represents the logical structure of the entire database for all users, independent of any specific DBMS or storage considerations.",
        },
        {
          q: "... enables different users to perceive data at their preferred level of detail.",
          options: ["Logical data", "Data abstraction", "Constrains"],
          id: 7,
          correct: "B",
          explanation:
            "Data abstraction hides the complexity of data storage and allows users to interact with data at different levels (physical, logical, view).",
        },
        {
          q: "Conceptual data model could be represented by .....",
          options: ["ERD", "DBMS", "DCL"],
          id: 8,
          correct: "A",
          explanation:
            "ERD (Entity Relationship Diagram) is a graphical representation of the conceptual data model showing entities, attributes, and relationships.",
        },
        {
          q: "... responsible for authorizing access to the database, coordinating and monitoring its use.",
          options: ["Relationship", "DBA", "Multi-value"],
          id: 9,
          correct: "B",
          explanation:
            "DBA (Database Administrator) is responsible for managing the database system including access control, monitoring, backup, and maintenance.",
        },
        {
          q: "... represent references as relationships not attributes.",
          options: ["ERD", "Redundancy", "Database model"],
          id: 10,
          correct: "A",
          explanation:
            "ERD represents connections between entities as relationships (shown by diamond shapes) rather than storing them as attributes within entities.",
        },
        {
          q: "The value of foreign key in a tuple...",
          options: [
            "Cannot be NULL",
            "Delete",
            "Occurring as value of primary key in another relation",
          ],
          id: 11,
          correct: "C",
          explanation:
            "A foreign key must match a primary key value in the referenced table, or be NULL if the relationship is optional. This maintains referential integrity.",
        },
        {
          q: "An attribute having more than one value is called.",
          options: ["Composite value", "Multi-value", "Complex value"],
          id: 12,
          correct: "B",
          explanation:
            "Multi-valued attribute can have multiple values for a single entity instance (e.g., a person can have multiple phone numbers).",
        },
        {
          type: "context",
          content: `<h3>Normalization Scenario</h3>
            <p><strong>Scenario:</strong> Real estate agent office renting properties (flat, house, store...).<br>
            The agent stores data about property and the client who will rent the property. Clients may rent different properties. The rent amount may change from client to client.<br>
            <strong>Relation R:</strong> (PropertyNo, PropertyAdd, type, OwnerID, OwnerName, ClientNo, ClientName, Start_date, Finish_date, rent_amount)</p>`,
        },
        {
          q: "The above relation R has ... partial dependency.",
          options: ["One", "Two", "Three"],
          id: 13,
          correct: "B",
          explanation:
            "There are two partial dependencies: (1) PropertyNo ‚Üí PropertyAdd, type, OwnerID, OwnerName, and (2) ClientNo ‚Üí ClientName. Both depend on part of the composite key.",
        },
        {
          q: "The above relation R has ... anomalies.",
          options: ["Insert", "Delete", "Both A & B"],
          id: 14,
          correct: "C",
          explanation:
            "The relation has both insert anomalies (can't add property without client) and delete anomalies (deleting last client removes property info). This is due to poor normalization.",
        },
        {
          q: "Which of the following relations are describing the 1st normal form relations?",
          options: [
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName, rent_amount<br>R2: PropertyNo, ClientNo, ClientName, Start_date, Finish_date",
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName<br>R2: PropertyNo, ClientNo, ClientName, Start_date, Finish_date, rent_amount",
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName<br>R2: PropertyNo, ClientNo, ClientName, Start_date, Finish_date, rent_amount",
          ],
          id: 15,
          correct: "B",
          explanation:
            "1NF requires eliminating repeating groups and having atomic values. Option B correctly separates property and rental information with proper primary keys.",
        },
        {
          q: "The 1st normal form relations have ....",
          options: [
            "Composite key",
            "Multi-value group(s)",
            "No multi-value groups",
          ],
          id: 16,
          correct: "C",
          explanation:
            "First Normal Form (1NF) requires that all attributes contain only atomic (single) values, meaning no multi-valued groups are allowed.",
        },
        {
          q: "Which of the following relations are describing the 2nd normal form relations?",
          options: [
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date, rent_amount<br>R2.2: ClientNo, ClientName",
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName, rent_amount<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date<br>R2.2: ClientNo, ClientName",
            "R1: PropertyNo, PropertyAdd, type, OwnerID, OwnerName<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date, rent_amount<br>R2.2: ClientNo, ClientName",
          ],
          id: 17,
          correct: "A",
          explanation:
            "2NF requires removing partial dependencies. Option A correctly eliminates ClientName's partial dependency on ClientNo by creating a separate relation.",
        },
        {
          q: "Which of the following relations are describing the 3rd normal form relations?",
          options: [
            "R1.1: PropertyNo, PropertyAdd, type, OwnerID, rent_amount<br>R1.2: OwnerID, OwnerName<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date<br>R2.2: ClientNo, ClientName",
            "R1.1: PropertyNo, PropertyAdd, type, OwnerID<br>R1.2: OwnerID, OwnerName<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date, rent_amount<br>R2.2: ClientNo, ClientName",
            "R1.1: PropertyNo, PropertyAdd, type, OwnerID<br>R1.2: OwnerID, OwnerName<br>R2.1: PropertyNo, ClientNo, Start_date, Finish_date, rent_amount<br>R2.2: ClientNo, ClientName",
          ],
          id: 18,
          correct: "B",
          explanation:
            "3NF requires removing transitive dependencies. OwnerName depends on OwnerID (not directly on PropertyNo), so it must be in a separate relation. Options B and C are identical and correct.",
        },
        {
          q: "Which of the following is not considering a characteristic of database approach?",
          options: [
            "Sharing of data",
            "Limited views of data",
            "Self-describing nature",
          ],
          id: 19,
          correct: "B",
          explanation:
            "Database approach provides multiple views of data (not limited views), allowing different users to see data in ways that suit their needs. Sharing and self-describing nature are key characteristics.",
        },
        {
          q: "The main cause of anomalies is:",
          options: [
            "The duplication of data in the relation",
            "The inconsistency of data in the relation",
            "The relation pertains to more than one entity type",
          ],
          id: 20,
          correct: "C",
          explanation:
            "Anomalies primarily occur when a relation stores information about more than one entity type, leading to redundancy and update/insert/delete problems.",
        },
        {
          q: "Which join refers to join records from the right table that have no matching key in the left table are included in the result?",
          options: ["Left outer join", "Right outer join", "Full outer join"],
          id: 21,
          correct: "B",
          explanation:
            "Right outer join includes all records from the right table and matching records from the left table. Non-matching left table records result in NULL values.",
        },
        {
          q: "The process of decomposing relations with anomalies to produce smaller, well-structured relations is called ........",
          options: ["Relation schema", "Normalization", "Mapping"],
          id: 22,
          correct: "B",
          explanation:
            "Normalization is the systematic process of organizing data to reduce redundancy and dependency by dividing large tables into smaller, well-structured ones.",
        },
        {
          q: "When you write: X ‚Üí Y this means:",
          options: [
            "The value of Y is determined by the value of X",
            "The value of X is determined by the value of Y",
            "X is functionally dependent on Y",
          ],
          id: 23,
          correct: "A",
          explanation:
            "X ‚Üí Y means Y is functionally dependent on X, i.e., for each value of X, there is exactly one corresponding value of Y. X determines Y.",
        },
        {
          q: "The three-schema approach doesn't include which of the following?",
          options: ["Internal", "Logical", "Client/Server"],
          id: 24,
          correct: "C",
          explanation:
            "The three-schema architecture includes: Internal (physical storage), Conceptual/Logical (overall database structure), and External (user views). Client/Server is not part of this.",
        },
        {
          q: "Number of employees working in a department attribute can be calculated from counting the number of rows of employees working in each department.",
          options: ["Stored attribute", "Derived attribute", "Weak attribute"],
          id: 25,
          correct: "B",
          explanation:
            "Derived attribute is computed from other attributes rather than being stored. The employee count can be calculated by counting employee records, so it's derived.",
        },
        {
          type: "context",
          content: `<h3>SQL Scenario</h3>
            <p><strong>Consider the following relations:</strong><br>
            Hotel (hotelNo, hotelName, city)<br>
            Room (Room#, hotelNo, type, price)<br>
            Guest (GuestID, guestName, address)<br>
            Booking (hotelNo, Room#, GuestID, dateFrom, dateTo, amount_paid)</p>`,
        },
        {
          q: "Retrieve each hotel name with the number of rooms in it.",
          options: [
            "Select hotelName from hotel join room on hotel.hotelNo=Room.hotelNo",
            "Select hotelName, count() from hotel join room on hotel.hotelNo=Room.hotelNo",
            "Select hotelName, count() from hotel join room on hotel.hotelNo=Room.hotelNo group by hotel.hotelNo, hotelName",
          ],
          id: 26,
          correct: "C",
          explanation:
            "To count rooms per hotel, we need COUNT(*) with GROUP BY. Option C correctly groups by hotel.hotelNo and hotelName to get the count for each hotel.",
        },
        {
          q: "Retrieve the room# in Hilton hotel that has never been booked.",
          options: [
            "Select room# from room join hotel on hotel.hotelNo=room.hotelNo where hotelName='Hilton' and room# not in (select room# from booking join hotel on booking.hotelNo=hotel.hotelNo where hotelName='Hilton')",
            "Select room# from room join hotel on hotel.hotelNo=room.hotelNo where hotelName='Hilton' and room# not in (select hotelNo from booking join hotel on booking.hotelNo=hotel.hotelNo where hotelName='Hilton')",
            "Select room# from room join hotel on hotel.hotelNo=room.hotelNo where hotelName='Hilton' and hotelName='Hilton'",
          ],
          id: 27,
          correct: "A",
          explanation:
            "Option A correctly uses NOT IN with a subquery to find Hilton rooms that don't appear in the booking table, identifying unbooked rooms.",
        },
        {
          q: "Retrieve all hotels that have rooms and also that haven't.",
          options: [
            "Select * from hotel left join room on hotel.hotelNo=room.hotelNo",
            "Select * from hotel join room on hotel.hotelNo=room.hotelNo",
            "Select * from hotel right join room on hotel.hotelNo=room.hotelNo",
          ],
          id: 28,
          correct: "A",
          explanation:
            "LEFT JOIN includes all hotels (even those without rooms) plus matching room data. Hotels without rooms will show NULL for room columns.",
        },
        {
          q: "Retrieve each guest name and the name of hotel he/she reserved starting from 1/1/2022 in Jeddah.",
          options: [
            "Select guestName, hotelName from booking join guest on booking.guestID= guest.guestID where city='Jeddah' and dateFrom=1/1/2022",
            "Select guestName, hotelName from booking join hotel on booking.hotelNo=hotel.hotelNo where city='Jeddah' and dateFrom=1/1/2022",
            "Select guestName, hotelName from booking join guest on booking.guestID= guest.guestID join hotel on booking.hotelNo=hotel.hotelNo where city='Jeddah' and dateFrom=1/1/2022",
          ],
          id: 29,
          correct: "C",
          explanation:
            "Need to join three tables: booking with guest (for guestName) and booking with hotel (for hotelName and city). Option C correctly performs both joins.",
        },
        {
          q: "Retrieve hotel name and the total price of all rooms in each hotel if the price is greater than 2000$",
          options: [
            "Select hotelName, price from hotel join room on hotel.hotelNo= room.hotelNo group by hotelName having price>2000",
            "Select hotelName, price from hotel join room on hotel.hotelNo=room.hotelNo where price >2000 group by price",
            "Select hotelName, price from hotel join room on hotel.hotelNo=room.hotelNo where price >2000",
          ],
          id: 30,
          correct: "A",
          explanation:
            "To get total price per hotel with condition on aggregate, use GROUP BY with HAVING. Option A groups by hotel and filters aggregated results with HAVING.",
        },
        {
          type: "erd-image",
          instruction:
            "Consider the following ERD then answer questions from (Q31 : Q40)",
        },
        {
          q: "Mapping Loan entity will be:",
          options: [
            "Loan: Loan_no, Amount, Type, Code, Branch_no",
            "Loan: Loan_no, Amount, Type",
            "Loan: Loan_no, Amount, Type, Branch_no",
          ],
          id: 31,
          correct: "C",
          explanation:
            "Loan entity maps to: Loan_no (PK), Amount, Type (its own attributes), plus Branch_no (FK) from the LOANS relationship connecting to BANK_BRANCH.",
        },
        {
          q: "Mapping Customer entity will be:",
          options: [
            "Customer : Ssn, Name, Addr, Phone, Loan_no, Acct_no",
            "Customer : Ssn, Name, Addr, Phone",
            "Customer : Ssn, Name, Addr, Phone, Acct_no",
          ],
          id: 32,
          correct: "B",
          explanation:
            "Customer entity contains only its direct attributes: Ssn (PK), Name, Addr, Phone. Relationships A_C and L_C are mapped as separate relations due to M:N cardinality.",
        },
        {
          q: "Mapping Account entity will be:",
          options: [
            "Account: Acct_no, balance, type",
            "Account: Acct_no, balance, type, Branch_no",
            "Account: Acct_no, balance, type, Code, Branch_no",
          ],
          id: 33,
          correct: "B",
          explanation:
            "Account maps to: Acct_no (PK), balance, type (own attributes), plus Branch_no (FK) from ACCTS relationship. Code is not needed as it's Bank's attribute.",
        },
        {
          q: "Mapping Bank entity will be:",
          options: [
            "Bank : Code, Name, Addr",
            "Bank : Code, Name, Addr, Branch_no",
            "Bank : Code, Name, Address",
          ],
          id: 34,
          correct: "A",
          explanation:
            "Bank is a regular strong entity with its own attributes: Code (PK), Name, Addr. Branch_no belongs to the weak entity BANK_BRANCH, not Bank.",
        },
        {
          q: "Mapping A_C relationship will be:",
          options: [
            "A_C: Acct_no, Ssn, Type",
            "A_C: Acct_no, addr, Type",
            "A_C: Acct_no, Ssn",
          ],
          id: 35,
          correct: "C",
          explanation:
            "A_C is an M:N relationship between Account and Customer, so it maps to a separate relation with both primary keys: Acct_no, Ssn (composite PK). No additional attributes shown.",
        },
        {
          q: "Mapping L_C relationship will be:",
          options: [
            "L_C: Loan_no, Ssn, Type",
            "L_C: Loan_no, addr, Type",
            "L_C: Loan_no, Ssn",
          ],
          id: 36,
          correct: "C",
          explanation:
            "L_C is an M:N relationship between Loan and Customer, mapping to: Loan_no, Ssn (composite PK). The diagram shows no additional attributes for this relationship.",
        },
        {
          q: "The attribute 'Branch_no' in 'Bank_Branch' entity is ...",
          options: ["Foreign key", "Partial key", "Primary key"],
          id: 37,
          correct: "B",
          explanation:
            "Branch_no is a partial key (discriminator) in the weak entity BANK_BRANCH. Combined with Code (from Bank), it forms the complete primary key.",
        },
        {
          q: "The degree of 'A_C' relationship is ...",
          options: ["Binary", "Ternary", "N-ary"],
          id: 38,
          correct: "A",
          explanation:
            "A_C relationship connects two entities (Account and Customer), making it a binary relationship (degree = 2).",
        },
        {
          q: "The Bank_Branch entity depends on which entity for its existence",
          options: ["Bank", "Loan", "Account"],
          id: 39,
          correct: "A",
          explanation:
            "BANK_BRANCH is a weak entity (shown by double rectangle) that depends on Bank (its owner entity) for existence. It cannot exist without a Bank.",
        },
        {
          q: "The Type attribute in Loan and Account entities is...",
          options: ["Simple", "Multi-value", "Derived"],
          id: 40,
          correct: "A",
          explanation:
            "Type is a simple (atomic) attribute in both Loan and Account entities - it stores a single value indicating the type of loan or account.",
        },
        { type: "context", content: "<h3>True / False Questions</h3>" },
        {
          q: "The entity type whose existence depends on another entity type is known as an associative entity.",
          options: ["True", "False"],
          id: 41,
          correct: "B",
          explanation:
            "False. An entity whose existence depends on another is called a weak entity, not an associative entity. Associative entities represent M:N relationships with attributes.",
        },
        {
          q: "Degree is the number of attributes in a relation.",
          options: ["True", "False"],
          id: 42,
          correct: "B",
          explanation:
            "False. Degree is the number of attributes (columns) in a relation. However, in relationship context, degree refers to the number of participating entities.",
        },
        {
          q: "Constraints are restrictions on the actual values in a database state.",
          options: ["True", "False"],
          id: 43,
          correct: "A",
          explanation:
            "True. Constraints define rules that restrict what values can be stored in the database, ensuring data integrity (e.g., NOT NULL, UNIQUE, CHECK).",
        },
        {
          q: "The composite attribute cannot be multi-value attribute.",
          options: ["True", "False"],
          id: 44,
          correct: "B",
          explanation:
            "False. A composite attribute can also be multi-valued. For example, a person can have multiple addresses, and each address is composite (street, city, zip).",
        },
        {
          q: "Relationships between entities can have attributes.",
          options: ["True", "False"],
          id: 45,
          correct: "A",
          explanation:
            "True. Relationships can have descriptive attributes. For example, an 'Enrollment' relationship between Student and Course can have a 'grade' attribute.",
        },
        {
          q: "In relational model, multi-valued and composite attributes are not allowed.",
          options: ["True", "False"],
          id: 46,
          correct: "A",
          explanation:
            "True. The relational model requires atomic values (1NF). Multi-valued and composite attributes must be decomposed into separate tables or atomic attributes.",
        },
        {
          q: "The domain constraint is implicit based constraint.",
          options: ["True", "False"],
          id: 47,
          correct: "A",
          explanation:
            "True. Domain constraints are implicit - they define the set of allowable values for each attribute based on its data type.",
        },
        {
          q: "Simplicity is considered one of the database disadvantages.",
          options: ["True", "False"],
          id: 48,
          correct: "B",
          explanation:
            "False. Simplicity is actually an advantage of databases. Disadvantages include complexity of setup, cost, and performance overhead.",
        },
        {
          q: "In the database environment, the software to process queries access the stored database to execute queries and retrieve required data.",
          options: ["True", "False"],
          id: 49,
          correct: "A",
          explanation:
            "True. The DBMS query processor accesses stored data to execute queries and return results to users or applications.",
        },
        {
          q: "The order of attributes in a relation is not important.",
          options: ["True", "False"],
          id: 50,
          correct: "A",
          explanation:
            "True. In relational model theory, the order of attributes (columns) is not significant. Attributes are referenced by name, not position.",
        },
      ];

      const quizContent = document.getElementById("quiz-content");

      quizData.forEach((item) => {
        if (item.type === "context") {
          const div = document.createElement("div");
          div.className = "context-box";
          div.innerHTML = item.content;
          quizContent.appendChild(div);
          return;
        }

        if (item.type === "erd-image") {
          const div = document.createElement("div");
          div.className = "erd-section";

          // üëá ÿ∂ÿπ ŸÖÿ≥ÿßÿ± ÿßŸÑÿµŸàÿ±ÿ© ŸáŸÜÿß
          const imagePath = "ERD.png"; // ÿ∫ŸäŸëÿ± Ÿáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿßÿ± ŸÑŸÖÿ≥ÿßÿ± ÿµŸàÿ±ÿ™ŸÉ

          div.innerHTML = `
            <div class="erd-header">
              <h3>üìä ERD Diagram Section</h3>
              <p>${item.instruction}</p>
            </div>
            <div class="erd-image-container">
              <div class="erd-upload-zone has-image">
                <img src="${imagePath}" alt="ERD Diagram - Bank Database" style="max-width: 100%; height: auto; border-radius: 8px; display: block;">
              </div>
              <p class="image-caption">ERD Diagram showing Bank, Branch, Loan, Customer, and Account entities</p>
            </div>
          `;
          quizContent.appendChild(div);
          return;
        }

        const card = document.createElement("div");
        card.className = "question-card";

        let optionsHtml = "";
        item.options.forEach((opt, index) => {
          const letter = String.fromCharCode(65 + index);
          optionsHtml += `
            <li class="option-item">
              <label class="option-label">
                <input type="radio" name="q${item.id}" value="${letter}">
                <div class="radio-custom"></div>
                <span class="option-text">(${letter}) ${opt}</span>
              </label>
            </li>
          `;
        });

        card.innerHTML = `
          <div class="q-header">
            <div class="q-number">${item.id}</div>
            <div class="q-text">${item.q}</div>
          </div>
          <ul class="options-list">
            ${optionsHtml}
          </ul>
        `;

        quizContent.appendChild(card);
      });

      // Function to check answers
      function checkAnswers() {
        let score = 0;
        let totalQuestions = 0;

        quizData.forEach((item) => {
          if (item.type === "context" || item.type === "erd-image") return;

          totalQuestions++;
          const userAnswer = document.querySelector(
            `input[name="q${item.id}"]:checked`
          );
          const questionCard = document
            .querySelector(`input[name="q${item.id}"]`)
            .closest(".question-card");

          // Remove previous explanations
          const oldExplanation = questionCard.querySelector(".explanation-box");
          if (oldExplanation) oldExplanation.remove();

          // Reset option styles
          questionCard.querySelectorAll(".option-label").forEach((label) => {
            label.classList.remove("correct", "wrong");
          });

          if (userAnswer) {
            const explanationDiv = document.createElement("div");
            explanationDiv.className = "explanation-box show";

            if (userAnswer.value === item.correct) {
              score++;
              explanationDiv.classList.add("correct");
              explanationDiv.innerHTML = `
                <div class="explanation-title">
                  <span>‚úÖ</span>
                  <span class="correct-answer">Correct!</span>
                </div>
                <p><strong>Explanation:</strong> ${item.explanation}</p>
              `;
              userAnswer.closest(".option-label").classList.add("correct");
            } else {
              explanationDiv.classList.add("wrong");
              const correctOption =
                item.options[item.correct.charCodeAt(0) - 65];
              explanationDiv.innerHTML = `
                <div class="explanation-title">
                  <span>‚ùå</span>
                  <span class="wrong-answer">Incorrect</span>
                </div>
                <p><strong>Your answer:</strong> (${userAnswer.value}) ${
                item.options[userAnswer.value.charCodeAt(0) - 65]
              }</p>
                <p><strong>Correct answer:</strong> (${
                  item.correct
                }) ${correctOption}</p>
                <p><strong>Explanation:</strong> ${item.explanation}</p>
              `;
              userAnswer.closest(".option-label").classList.add("wrong");

              // Highlight correct answer
              const correctInput = questionCard.querySelector(
                `input[value="${item.correct}"]`
              );
              if (correctInput) {
                correctInput.closest(".option-label").classList.add("correct");
              }
            }

            questionCard.appendChild(explanationDiv);
          } else {
            // No answer selected
            const explanationDiv = document.createElement("div");
            explanationDiv.className = "explanation-box show wrong";
            const correctOption = item.options[item.correct.charCodeAt(0) - 65];
            explanationDiv.innerHTML = `
              <div class="explanation-title">
                <span>‚ö†Ô∏è</span>
                <span class="wrong-answer">Not Answered</span>
              </div>
              <p><strong>Correct answer:</strong> (${item.correct}) ${correctOption}</p>
              <p><strong>Explanation:</strong> ${item.explanation}</p>
            `;
            questionCard.appendChild(explanationDiv);

            // Highlight correct answer
            const correctInput = questionCard.querySelector(
              `input[value="${item.correct}"]`
            );
            if (correctInput) {
              correctInput.closest(".option-label").classList.add("correct");
            }
          }
        });

        // Display score
        const percentage = ((score / totalQuestions) * 100).toFixed(1);
        const resultSection = document.getElementById("resultSection");
        const scoreDisplay = document.getElementById("scoreDisplay");

        let grade = "";
        let emoji = "";
        if (percentage >= 90) {
          grade = "Excellent";
          emoji = "üèÜ";
        } else if (percentage >= 80) {
          grade = "Very Good";
          emoji = "üåü";
        } else if (percentage >= 70) {
          grade = "Good";
          emoji = "üëç";
        } else if (percentage >= 60) {
          grade = "Pass";
          emoji = "‚úîÔ∏è";
        } else {
          grade = "Needs Improvement";
          emoji = "üìö";
        }

        scoreDisplay.innerHTML = `
          <h2>${emoji} Your Score: ${score} / ${totalQuestions}</h2>
          <p style="font-size: 1.5rem; margin: 10px 0;">${percentage}%</p>
          <p style="font-size: 1.2rem;">${grade}</p>
        `;

        resultSection.classList.add("show");
        resultSection.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }
    </script>
  </body>
</html>
